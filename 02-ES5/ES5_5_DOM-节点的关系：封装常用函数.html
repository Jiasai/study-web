<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>节点的关系：封装常用函数</title>
	</head>
	<body>

		<div id="box">
			<p id='ipara'>我是段落i</p>
			<p id='fpara'>我是段落A</p>
			<!-- 我是注释 -->
			<p id='para'>我是段落B
				<span></span>
				<span></span>
				<span></span>
				<span></span>
			</p>
			<p id='nPara'>我是段落C</p>
			<p>我是段落d</p>
			<p>我是段落f</p>
		</div>

		<script type="text/javascript">
			var box = document.getElementById('box');
			var para = document.getElementById('para');
			var fpara = document.getElementById('fpara');

			// //封装一个函数，这个函数可以返回元素的所有子节点（兼容到IE6）,类似 children功能			
			// function getChildren(node) {
			// 	//准备一个结果数组
			// 	var children = [];
			// 	//遍历这个nodes节点的所有子节点，判断子节点的nodeType属性是不是1
			// 	//如果是 1 推入新的数组
			// 	for (var i = 0; i < node.childNodes.length; i++) {
			// 		if (node.childNodes[i].nodeType == 1) {
			// 			children.push(node.childNodes[i]);
			// 		}
			// 	}
			// 	return children;
			// }
			// var children_lis = getChildren(box);
			// console.log(children_lis[1]);

			// var span_lis = getChildren(para);
			// console.log(span_lis);
			
			
			//封装一个函数，可以返回元素前一个兄弟元素节点，兼容到IE6，类似 previousElementSibling的功能
			
			// function getElementPrevSibling(node) {
			// 	var o = node;
			// 	while(o.previousSibling != null){  // 这个节点不是第一个节点，前面没有兄弟节点
			// 		if(o.previousSibling.nodeType == 1){ //如果前面节点是元素节点，返回这个节点
			// 			return o.previousSibling;
			// 		}
					
			// 		o = o.previousSibling; //如果前面的节点不满足，把这个这个节点赋值o变量，继续循环，往前寻找
			// 	}
			// 	return null;
			// }
			// console.log(getElementPrevSibling(para));
			// console.log(getElementPrevSibling(fpara));
			
			function getAllElementSibling(node) {
				//前面的元素节点
				var prev = [];
				//后面的元素节点
				var nets = [];
				
				var o = node;
				//遍历node 前面的节点
				while(o.previousSibling != null){
					if(o.previousSibling.nodeType == 1){
						prev.unshift(o.previousSibling);
					}
					o = o.previousSibling;
				}
				
				o = node;
				//遍历node 后面的节点
				while(o.nextSibling != null){
					if(o.nextSibling.nodeType == 1){
						nets.push(o.nextSibling);
					}
					o = o.nextSibling;
				}
				//将两个数组进行合并，然后返回	
				return prev.concat(nets);
				
			}
			
			var AllElementSibling = getAllElementSibling(para);
			console.log(AllElementSibling);
			
		</script>

	</body>
</html>
